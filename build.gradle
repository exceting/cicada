apply from: 'libs.gradle'
apply from: 'artifacts.gradle'

allprojects {
    apply plugin: 'idea'

    repositories {
        mavenCentral()
        maven { url "https://repo1.maven.org/maven2/" }
    }

    // print all dependencies in multi-module project
    // usage: './gradlew printAllDependencies'
    task printAllDependencies(type: DependencyReportTask) {}
}

subprojects {
    buildscript {
        repositories {
            mavenCentral()
            maven { url "https://repo1.maven.org/maven2/" }
            maven { url "https://plugins.gradle.org/m2" }
        }

        dependencies {
            classpath libs["gradle-lombok"]
            classpath libs["errorprone-gradle"]
        }
    }
}

configure(subprojects) { subProject ->
    subProject.pluginManager.withPlugin('java', {
        subProject.sourceSets.main.resources {
            srcDirs 'src/main/resources', 'src/main/java'
        }
    })

    ext {
        artifactId = rootProject.ext.artifacts[project.path] ? rootProject.ext.artifacts[project.path] : project.name
    }

    pluginManager.withPlugin('java', {
        processResources {
            duplicatesStrategy = DuplicatesStrategy.INCLUDE
        }

        apply plugin: "io.franzbecker.gradle-lombok"
        lombok {
            version = versions['lombok']
            sha256 = ""
        }

        def libP = [':tools']
        def isLib = libP.any { p ->
            path.startsWith(p)
        }
        tasks.withType(JavaCompile).tap {
            configureEach {
                sourceCompatibility = isLib ? 1.8 : 11
                targetCompatibility = isLib ? 1.8 : 11
                options.encoding = 'UTF-8'
            }
        }

        jar {
            enabled = true
        }

        task sourcesJar(type: Jar) {
            from sourceSets.main.allJava
            archiveClassifier = 'sources'
        }

        /*task sourcesJar(type: Jar, dependsOn: classes) {
            group = LifecycleBasePlugin.BUILD_GROUP
            duplicatesStrategy = DuplicatesStrategy.INCLUDE
            archiveClassifier.set('sources')
            archiveBaseName.set(project.artifactId)
        }*/
    })

    def canPublish = subProject.name.startsWith("logtrace")
    if (canPublish) {
        pluginManager.withPlugin('java-library', {
            //apply maven plugin
            apply plugin: 'maven-publish'

            jar {
                archiveBaseName.set(project.artifactId)
            }
        })

        pluginManager.withPlugin('java-platform', {
            //apply maven plugin
            apply plugin: 'maven-publish'
        })

        group = 'io.github.exceting'

        pluginManager.withPlugin('maven-publish', {

            apply plugin: 'signing'

            publishing {
                repositories {
                    maven {
                        url = version.endsWith('SNAPSHOT') ? snapshotRepo : releaseRepo
                        credentials {
                            username = repoUserName
                            password = repoPassword
                        }
                    }
                }

                signing {
                    sign configurations.archives
                }

                publications {
                    maven(MavenPublication) {
                        artifactId = project.artifactId
                        from components.java
                        artifact sourcesJar

                        pom {
                            name = 'Cicada'
                            description = 'Cicada Tools Mono Repo.'
                            url = 'https://github.com/exceting/cicada'

                            scm {
                                connection = 'scm:git:git://github.com/exceting/cicada.git'
                                url = 'https://github.com/exceting/cicada'
                            }
                            withXml {
                                asNode().dependencies.'*'.findAll() {
                                    it.scope.text() == 'runtime' && project.configurations.implementation.dependencies.find { dep ->
                                        if (dep instanceof ProjectDependency) {
                                            def p = dep.dependencyProject
                                            p.artifactId == it.artifactId.text() && p.group == it.groupId.text()
                                        } else if (dep instanceof ExternalModuleDependency) {
                                            dep.name == it.artifactId.text() && dep.group == it.groupId.text()
                                        } else {
                                            dep.name == it.artifactId.text()
                                        }
                                    }
                                }.each() {
                                    it.scope*.value = 'compile'
                                }
                            }
                        }
                    }
                }
            }
        })
    }

    //clean task
    def cleanTasks = getTasksByName('clean', false)
    if (cleanTasks != null && cleanTasks.size() > 0) {
        clean {
            delete 'out'
        }
    }
}

